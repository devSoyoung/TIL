# [TIL] 2020-04-14

## ğŸ’» [JAVA] 2ì°¨ì› ë°°ì—´ ì´ˆê¸°í™”
[Arrays.fill with multidimensional array in Java - Stack Overflow](https://stackoverflow.com/questions/7118178/arrays-fill-with-multidimensional-array-in-java)

```java
double[][] matrix = new double[20][4];

// Fill each row with 1.0
for (double[] row: matrix)
    Arrays.fill(row, 1.0);
```

## ğŸŒ ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)ê³¼ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)
> **Ref** : [ì•Œê³ ë¦¬ì¦˜ ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS) ê³¼ ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS) :: Yun Youngâ€™s Programming Blog!](https://yunyoung1819.tistory.com/86)  

* âš ï¸ ê·¸ë˜í”„ íƒìƒ‰ì˜ ê²½ìš° ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì²´í¬í•˜ì§€ ì•Šìœ¼ë©´ ë¬´í•œë£¨í”„ì— ë¹ ì§ˆ ìœ„í—˜ì´ ìˆìŒ

### ğŸ“ ê¹Šì´ ìš°ì„  íƒìƒ‰
ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•´ ë‹¤ìŒ ë¶„ê¸°ë¡œ ë„˜ì–´ê°€ê¸° ì „ì—, í•´ë‹¹ ë¶„ê¸°ë¥¼ ì™„ë²½í•˜ê²Œ(=ëê¹Œì§€) íƒìƒ‰í•˜ëŠ” ê²ƒ
* ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê³ ì í•˜ëŠ” ê²½ìš°ì— ì‚¬ìš©í•˜ëŠ” ë°©ë²•
* DFSê°€ BFSë³´ë‹¤ êµ¬í˜„ì´ ì¢€ ë” ê°„ë‹¨í•¨
* ê²€ìƒ‰ ì†ë„ ìì²´ëŠ” BFSì— ë¹„í•´ì„œ ì¡°ê¸ˆ ë” ëŠë¦¼
* **êµ¬í˜„** : ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” ìˆœí™˜ ì•Œê³ ë¦¬ì¦˜ì˜ í˜•íƒœë¥¼ ì§€ë‹˜

### ğŸ“ ë„ˆë¹„ ìš°ì„  íƒìƒ‰
ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•´ ì¸ì ‘í•œ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•˜ëŠ” ë°©ë²•
* ì‹œì‘ ì •ì ì—ì„œ ê°€ê¹Œìš´ ì •ì ì„ ë¨¼ì € ë°©ë¬¸í•˜ê³ , ë©€ë¦¬ ìˆëŠ” ì •ì ì€ ë‚˜ì¤‘ì— ë°©ë¬¸í•˜ëŠ” ìˆœíšŒ ë°©ë²•
* ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œ í˜¹ì€ ì„ì˜ì˜ ê²½ë¡œë¥¼ ì°¾ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•
* BFSëŠ” ì¬ê·€ì ìœ¼ë¡œ ë™ì‘í•˜ì§€ ì•ŠìŒ
* ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì°¨ë¡€ëŒ€ë¡œ êº¼ë‚¼ ìˆ˜ ìˆëŠ” ì„ ì…ì„ ì¶œì˜ í ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©

## ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´: 2048
[ê¸€ ì½ê¸° - 12100ë²ˆ 2048(Easy) í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ëŠ” í†µê³¼í•˜ëŠ”ë° í‹€ë ¸ìŠµë‹ˆë‹¤ê°€ ëœ¹ë‹ˆë‹¤.](https://www.acmicpc.net/board/view/29779)

```java
package com.company;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
    private static int n;   // 1 - 20

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // ì´ˆê¸° ìƒíƒœ ì…ë ¥ ë°›ê¸°
        n = sc.nextInt();
        int[][] map = new int[n][n];
        int max = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                map[i][j] = sc.nextInt();

                if (map[i][j] > max) {
                    max = map[i][j];
                }
            }
        }

        Node root = new Node(map, max, 0);
        int result = bfs(root);
        System.out.println(result);
    }

    // íƒìƒ‰í•˜ê¸°
    public static int bfs(Node root) {
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        int result = root.max;

        while (!queue.isEmpty()) {
            Node cur = queue.poll();
            if (cur.count == 5) {
                break;
            }

            Queue<Integer> temp = new LinkedList<>();
            Queue<Integer> merged = new LinkedList<>();

            // ìƒ
            Node temp_up = new Node(cur.map, cur.max, cur.count + 1);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (cur.map[j][i] != 0) {
                        temp.offer(cur.map[j][i]);
                    }
                }

                if (temp.isEmpty()) {
                    for (int k = 0; k < n; k++) {
                        temp_up.map[k][i] = 0;
                    }
                    continue;
                }

                // Queue ë½‘ê³  ì§‘ì–´ë„£ê¸°
                int curValue = temp.poll();
                while (!temp.isEmpty()) {
                    int top = temp.poll();
                    if (top == 0) continue;

                    if (curValue == top) {
                        merged.offer(top * 2);
                        result = Math.max(top * 2, result);
                        temp_up.max = Math.max(temp_up.max, top * 2);
                        curValue = 0;
                    } else {
                        if (curValue != 0) {
                            merged.offer(curValue);
                        }
                        curValue = top;
                    }
                }
                if (curValue != 0) {
                    merged.offer(curValue);
                }

                // ìƒˆë¡œìš´ ê²°ê³¼ë¥¼ map ì— ì €ì¥í•˜ê¸°
                for (int k = 0; k < n; k++) {
                    if (merged.isEmpty()) {
                        temp_up.map[k][i] = 0;
                    } else {
                        temp_up.map[k][i] = merged.poll();
                    }
                }
            }
            if (!isSame(temp_up.map, cur.map)) {
                queue.offer(temp_up);
            }

            // í•˜
            Node temp_down = new Node(cur.map, cur.max, cur.count + 1);
            for (int i = 0; i < n; i++) {
                for (int j = n - 1; j >= 0; j--) {
                    if (cur.map[j][i] != 0) {
                        temp.offer(cur.map[j][i]);
                    }
                }

                if (temp.isEmpty()) {
                    for (int k = 0; k < n; k++) {
                        temp_down.map[k][i] = 0;
                    }
                    continue;
                }

                // Queue ë½‘ê³  ì§‘ì–´ë„£ê¸°
                int curValue = temp.poll();
                while (!temp.isEmpty()) {
                    int top = temp.poll();
                    if (top == 0) continue;

                    if (curValue == top) {
                        merged.offer(top * 2);
                        result = Math.max(top * 2, result);
                        temp_down.max = Math.max(temp_down.max, top * 2);
                        curValue = 0;
                    } else {
                        if (curValue != 0) {
                            merged.offer(curValue);
                        }
                        curValue = top;
                    }
                }
                if (curValue != 0) {
                    merged.offer(curValue);
                }

                // ìƒˆë¡œìš´ ê²°ê³¼ë¥¼ map ì— ì €ì¥í•˜ê¸°
                for (int k = n - 1; k >= 0; k--) {
                    if (merged.isEmpty()) {
                        temp_down.map[k][i] = 0;
                    } else {
                        temp_down.map[k][i] = merged.poll();
                    }
                }
            }
            if (!isSame(temp_down.map, cur.map)) {
                queue.offer(temp_down);
            }

            // ì¢Œ
            Node temp_left = new Node(cur.map, cur.max, cur.count + 1);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (cur.map[j][i] != 0) {
                        temp.offer(cur.map[j][i]);
                    }
                }

                if (temp.isEmpty()) {
                    for (int k = 0; k < n; k++) {
                        temp_left.map[i][k] = 0;
                    }
                    continue;
                }

                // Queue ë½‘ê³  ì§‘ì–´ë„£ê¸°
                int curValue = temp.poll();
                while (!temp.isEmpty()) {
                    int top = temp.poll();
                    if (top == 0) continue;

                    if (curValue == top) {
                        merged.offer(top * 2);
                        result = Math.max(top * 2, result);
                        temp_left.max = Math.max(temp_left.max, top * 2);
                        curValue = 0;
                    } else {
                        if (curValue != 0) {
                            merged.offer(curValue);
                        }
                        curValue = top;
                    }
                }
                if (curValue != 0) {
                    merged.offer(curValue);
                }

                // ìƒˆë¡œìš´ ê²°ê³¼ë¥¼ map ì— ì €ì¥í•˜ê¸°
                for (int k = 0; k < n; k++) {
                    if (merged.isEmpty()) {
                        temp_left.map[i][k] = 0;
                    } else {
                        temp_left.map[i][k] = merged.poll();
                    }
                }
            }
            if (!isSame(temp_left.map, cur.map)) {
                queue.offer(temp_left);
            }

            // ìš°
            Node temp_right = new Node(cur.map, cur.max, cur.count + 1);
            for (int i = 0; i < n; i++) {
                for (int j = n - 1; j > 0; j--) {
                    if (cur.map[j][i] != 0) {
                        temp.offer(cur.map[j][i]);
                    }
                }

                if (temp.isEmpty()) {
                    for (int k = 0; k < n; k++) {
                        temp_right.map[i][k] = 0;
                    }
                    continue;
                }

                // Queue ë½‘ê³  ì§‘ì–´ë„£ê¸°
                int curValue = temp.poll();
                while (!temp.isEmpty()) {
                    int top = temp.poll();
                    if (top == 0) continue;

                    if (curValue == top) {
                        merged.offer(top * 2);
                        result = Math.max(top * 2, result);
                        temp_right.max = Math.max(temp_right.max, top * 2);
                        curValue = 0;
                    } else {
                        if (curValue != 0) {
                            merged.offer(curValue);
                        }
                        curValue = top;
                    }
                }
                if (curValue != 0) {
                    merged.offer(curValue);
                }

                // ìƒˆë¡œìš´ ê²°ê³¼ë¥¼ map ì— ì €ì¥í•˜ê¸°
                for (int k = n - 1; k > 0; k--) {
                    if (merged.isEmpty()) {
                        temp_right.map[i][k] = 0;
                    } else {
                        temp_right.map[i][k] = merged.poll();
                    }
                }
            }
            if (!isSame(temp_right.map, cur.map)) {
                queue.offer(temp_right);
            }
        }

        return result;
    }

    private static boolean isSame(int[][] arr1, int[][] arr2) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (arr1[i][j] != arr2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
}

class Node {
    int[][] map;
    int max;
    int count;

    Node(int[][] map, int max, int count) {
        this.max = max;
        this.count = count;

        // map ê¹Šì€ ë³µì‚¬
        this.map = new int[map.length][map.length];
        for (int i = 0; i < map.length; i++) {
            System.arraycopy(map[i], 0, this.map[i], 0, map.length);
        }
    }
}
```

ìœ„ì— ì²¨ë¶€í•œ ë§í¬ ê¸€ì„ ë³´ê³  ê³ ë ¤í–ˆëŠ”ë°ë„, 2048ì´ ì•ˆê³ ì³ì§„ë‹¤.. ë­ê°€ ë¬¸ì œì§€ ğŸ˜­
